/**
 * BSP AML Monitoring Service
 *
 * Anti-Money Laundering threshold monitoring for BSP compliance
 * Monitors transactions for AML thresholds and generates alerts
 *
 * @module lib/compliance/bsp/aml-monitoring
 */

import { query } from '../../db';
import {
  AMLMonitoringRecord,
  TransactionMonitoringRequest,
  MonitoringResult,
  RiskAssessmentResult,
  ComplianceAlert,
  SuspiciousActivity,
  BSP_AML_THRESHOLDS,
  RiskLevel,
  AMLThresholdError,
} from './types';

/**
 * AML Monitoring Service
 *
 * Monitors transactions for AML compliance:
 * - Single transaction threshold: ₱50,000
 * - Daily cumulative threshold: ₱100,000
 * - Monthly cumulative threshold: ₱500,000
 */
export class AMLMonitoringService {
  /**
   * Monitor a transaction for AML compliance
   *
   * @param request - Transaction monitoring request
   * @returns Monitoring result with alerts and flags
   */
  async monitorTransaction(request: TransactionMonitoringRequest): Promise<MonitoringResult> {
    try {
      // Calculate cumulative amounts
      const dailyCumulative = await this.getDailyCumulative(request.userId, request.transactionDate);
      const monthlyCumulative = await this.getMonthlyCumulative(request.userId, request.transactionDate);

      // Check thresholds
      const exceedsSingle = request.amount >= BSP_AML_THRESHOLDS.singleTransaction;
      const exceedsDaily = dailyCumulative + request.amount >= BSP_AML_THRESHOLDS.dailyCumulative;
      const exceedsMonthly = monthlyCumulative + request.amount >= BSP_AML_THRESHOLDS.monthlyCumulative;

      // Perform risk assessment
      const riskAssessment = this.assessRisk({
        amount: request.amount,
        dailyCumulative: dailyCumulative + request.amount,
        monthlyCumulative: monthlyCumulative + request.amount,
        exceedsSingle,
        exceedsDaily,
        exceedsMonthly,
        transactionType: request.transactionType,
      });

      // Create AML monitoring record
      const amlRecord: AMLMonitoringRecord = {
        transactionId: request.transactionId,
        paymentId: request.paymentId,
        amount: request.amount,
        currency: request.currency,
        transactionType: request.transactionType,
        userId: request.userId,
        userType: request.userType,
        userName: request.userName,
        userPhone: request.userPhone,
        userEmail: request.userEmail,
        exceedsSingleThreshold: exceedsSingle,
        exceedsDailyThreshold: exceedsDaily,
        exceedsMonthlyThreshold: exceedsMonthly,
        dailyCumulativeAmount: dailyCumulative + request.amount,
        monthlyCumulativeAmount: monthlyCumulative + request.amount,
        riskLevel: riskAssessment.riskLevel,
        riskScore: riskAssessment.riskScore,
        riskFactors: riskAssessment.riskFactors,
        flaggedForReview: exceedsSingle || exceedsDaily || exceedsMonthly || riskAssessment.riskLevel === 'high' || riskAssessment.riskLevel === 'critical',
        reviewed: false,
        reportedToBsp: false,
        transactionDate: request.transactionDate,
      };

      // Store AML record in database
      const storedRecord = await this.storeAMLRecord(amlRecord);

      // Note: Alerts are automatically generated by database triggers
      // We'll fetch any alerts that were created
      const alerts = await this.getAlertsForTransaction(request.transactionId);

      // Detect suspicious patterns
      const suspiciousActivities = await this.detectSuspiciousPatterns(request.userId, request.userType);

      return {
        monitored: true,
        amlRecord: storedRecord,
        alertsTriggered: alerts,
        suspiciousActivitiesDetected: suspiciousActivities,
        requiresReview: amlRecord.flaggedForReview,
        reportedToBsp: false,
      };
    } catch (error) {
      console.error('AML monitoring failed:', error);
      throw new AMLThresholdError('Failed to monitor transaction for AML compliance', {
        transactionId: request.transactionId,
        error: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  }

  /**
   * Get daily cumulative amount for a user
   */
  private async getDailyCumulative(userId: string, transactionDate: Date): Promise<number> {
    const result = await query<{ total: string }>(
      `SELECT COALESCE(SUM(amount), 0) as total
       FROM bsp_aml_monitoring
       WHERE user_id = $1
       AND DATE(transaction_date) = DATE($2)`,
      [userId, transactionDate]
    );

    return parseFloat(result.rows[0]?.total || '0');
  }

  /**
   * Get monthly cumulative amount for a user
   */
  private async getMonthlyCumulative(userId: string, transactionDate: Date): Promise<number> {
    const result = await query<{ total: string }>(
      `SELECT COALESCE(SUM(amount), 0) as total
       FROM bsp_aml_monitoring
       WHERE user_id = $1
       AND DATE_TRUNC('month', transaction_date) = DATE_TRUNC('month', $2::timestamp)`,
      [userId, transactionDate]
    );

    return parseFloat(result.rows[0]?.total || '0');
  }

  /**
   * Assess risk level based on transaction characteristics
   */
  private assessRisk(params: {
    amount: number;
    dailyCumulative: number;
    monthlyCumulative: number;
    exceedsSingle: boolean;
    exceedsDaily: boolean;
    exceedsMonthly: boolean;
    transactionType: string;
  }): RiskAssessmentResult {
    let riskScore = 0;
    const riskFactors: string[] = [];

    // Single transaction threshold
    if (params.exceedsSingle) {
      riskScore += 30;
      riskFactors.push('high_amount');
    }

    // Daily threshold
    if (params.exceedsDaily) {
      riskScore += 25;
      riskFactors.push('daily_threshold_exceeded');
    }

    // Monthly threshold
    if (params.exceedsMonthly) {
      riskScore += 35;
      riskFactors.push('monthly_threshold_exceeded');
    }

    // Very high amount (> ₱100,000)
    if (params.amount > 100000) {
      riskScore += 20;
      riskFactors.push('very_high_amount');
    }

    // Round amounts (suspicious)
    if (params.amount % 10000 === 0 && params.amount >= 50000) {
      riskScore += 10;
      riskFactors.push('round_amount');
    }

    // Determine risk level
    let riskLevel: RiskLevel;
    if (riskScore >= 75) {
      riskLevel = 'critical';
    } else if (riskScore >= 50) {
      riskLevel = 'high';
    } else if (riskScore >= 25) {
      riskLevel = 'medium';
    } else {
      riskLevel = 'low';
    }

    return {
      riskLevel,
      riskScore: Math.min(riskScore, 100),
      riskFactors,
      recommendations: this.getRecommendations(riskLevel, riskFactors),
    };
  }

  /**
   * Get recommendations based on risk level
   */
  private getRecommendations(riskLevel: RiskLevel, riskFactors: string[]): string[] {
    const recommendations: string[] = [];

    if (riskLevel === 'critical') {
      recommendations.push('Immediate manual review required');
      recommendations.push('Verify user identity and transaction purpose');
      recommendations.push('Consider filing Suspicious Activity Report (SAR) to BSP');
    } else if (riskLevel === 'high') {
      recommendations.push('Manual review recommended');
      recommendations.push('Document transaction justification');
    } else if (riskLevel === 'medium') {
      recommendations.push('Monitor user for further activity');
    }

    if (riskFactors.includes('daily_threshold_exceeded')) {
      recommendations.push('Review all transactions for the day');
    }

    if (riskFactors.includes('monthly_threshold_exceeded')) {
      recommendations.push('Review monthly transaction pattern');
    }

    return recommendations;
  }

  /**
   * Store AML monitoring record in database
   */
  private async storeAMLRecord(record: AMLMonitoringRecord): Promise<AMLMonitoringRecord> {
    const result = await query<AMLMonitoringRecord>(
      `INSERT INTO bsp_aml_monitoring (
        transaction_id, payment_id, amount, currency, transaction_type,
        user_id, user_type, user_name, user_phone, user_email,
        exceeds_single_threshold, exceeds_daily_threshold, exceeds_monthly_threshold,
        daily_cumulative_amount, monthly_cumulative_amount,
        risk_level, risk_score, risk_factors,
        flagged_for_review, reviewed, reported_to_bsp,
        transaction_date
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
        $11, $12, $13, $14, $15, $16, $17, $18,
        $19, $20, $21, $22
      ) RETURNING *`,
      [
        record.transactionId,
        record.paymentId || null,
        record.amount,
        record.currency,
        record.transactionType,
        record.userId,
        record.userType,
        record.userName || null,
        record.userPhone || null,
        record.userEmail || null,
        record.exceedsSingleThreshold,
        record.exceedsDailyThreshold,
        record.exceedsMonthlyThreshold,
        record.dailyCumulativeAmount,
        record.monthlyCumulativeAmount,
        record.riskLevel,
        record.riskScore,
        JSON.stringify(record.riskFactors),
        record.flaggedForReview,
        record.reviewed,
        record.reportedToBsp,
        record.transactionDate,
      ]
    );

    return this.mapAMLRecord(result.rows[0]);
  }

  /**
   * Get alerts for a transaction
   */
  private async getAlertsForTransaction(transactionId: string): Promise<ComplianceAlert[]> {
    const result = await query<any>(
      `SELECT * FROM bsp_compliance_alerts
       WHERE transaction_id = $1
       ORDER BY triggered_at DESC`,
      [transactionId]
    );

    return result.rows.map(this.mapAlert);
  }

  /**
   * Detect suspicious patterns for a user
   */
  private async detectSuspiciousPatterns(userId: string, userType: string): Promise<SuspiciousActivity[]> {
    // Check for structuring (multiple transactions just below threshold)
    const structuring = await this.detectStructuring(userId);

    // Check for rapid succession
    const rapidSuccession = await this.detectRapidSuccession(userId);

    return [...structuring, ...rapidSuccession];
  }

  /**
   * Detect structuring pattern (breaking up large amounts)
   */
  private async detectStructuring(userId: string): Promise<SuspiciousActivity[]> {
    const result = await query<any>(
      `SELECT
        COUNT(*) as transaction_count,
        SUM(amount) as total_amount,
        JSON_AGG(
          JSON_BUILD_OBJECT(
            'transactionId', transaction_id,
            'amount', amount,
            'timestamp', transaction_date
          )
        ) as transactions
       FROM bsp_aml_monitoring
       WHERE user_id = $1
       AND transaction_date >= NOW() - INTERVAL '24 hours'
       AND amount BETWEEN 40000 AND 49999
       GROUP BY user_id
       HAVING COUNT(*) >= 3`,
      [userId]
    );

    const activities: SuspiciousActivity[] = [];

    for (const row of result.rows) {
      if (parseInt(row.transaction_count) >= 3) {
        // Store suspicious activity
        const activity = await this.storeSuspiciousActivity({
          activityType: 'structuring',
          userId,
          userType: 'passenger', // Will be updated with actual type
          patternDescription: `User made ${row.transaction_count} transactions totaling ₱${row.total_amount} in 24 hours, all just below ₱50,000 threshold`,
          severity: 'high',
          detectionMethod: 'automated',
          relatedTransactions: JSON.parse(row.transactions),
          evidence: {
            transactionCount: parseInt(row.transaction_count),
            totalAmount: parseFloat(row.total_amount),
            timeSpanMinutes: 24 * 60,
          },
          status: 'detected',
          falsePositive: false,
          reportedToBsp: false,
          detectedAt: new Date(),
        });

        activities.push(activity);
      }
    }

    return activities;
  }

  /**
   * Detect rapid succession pattern
   */
  private async detectRapidSuccession(userId: string): Promise<SuspiciousActivity[]> {
    const result = await query<any>(
      `SELECT
        COUNT(*) as transaction_count,
        SUM(amount) as total_amount,
        EXTRACT(EPOCH FROM (MAX(transaction_date) - MIN(transaction_date))) / 60 as time_span_minutes,
        JSON_AGG(
          JSON_BUILD_OBJECT(
            'transactionId', transaction_id,
            'amount', amount,
            'timestamp', transaction_date
          )
        ) as transactions
       FROM bsp_aml_monitoring
       WHERE user_id = $1
       AND transaction_date >= NOW() - INTERVAL '1 hour'
       GROUP BY user_id
       HAVING COUNT(*) >= 5`,
      [userId]
    );

    const activities: SuspiciousActivity[] = [];

    for (const row of result.rows) {
      if (parseInt(row.transaction_count) >= 5 && parseFloat(row.time_span_minutes) <= 60) {
        // Store suspicious activity
        const activity = await this.storeSuspiciousActivity({
          activityType: 'rapid_succession',
          userId,
          userType: 'passenger',
          patternDescription: `User made ${row.transaction_count} transactions totaling ₱${row.total_amount} within ${Math.round(row.time_span_minutes)} minutes`,
          severity: 'medium',
          detectionMethod: 'automated',
          relatedTransactions: JSON.parse(row.transactions),
          evidence: {
            transactionCount: parseInt(row.transaction_count),
            totalAmount: parseFloat(row.total_amount),
            timeSpanMinutes: parseFloat(row.time_span_minutes),
          },
          status: 'detected',
          falsePositive: false,
          reportedToBsp: false,
          detectedAt: new Date(),
        });

        activities.push(activity);
      }
    }

    return activities;
  }

  /**
   * Store suspicious activity in database
   */
  private async storeSuspiciousActivity(activity: SuspiciousActivity): Promise<SuspiciousActivity> {
    const result = await query<any>(
      `INSERT INTO bsp_suspicious_activity (
        activity_type, user_id, user_type, pattern_description,
        severity, detection_method, related_transactions, evidence,
        status, false_positive, reported_to_bsp, detected_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
       RETURNING *`,
      [
        activity.activityType,
        activity.userId,
        activity.userType,
        activity.patternDescription,
        activity.severity,
        activity.detectionMethod,
        JSON.stringify(activity.relatedTransactions),
        JSON.stringify(activity.evidence),
        activity.status,
        activity.falsePositive,
        activity.reportedToBsp,
        activity.detectedAt,
      ]
    );

    return this.mapSuspiciousActivity(result.rows[0]);
  }

  /**
   * Get flagged transactions for review
   */
  async getFlaggedTransactions(limit = 50): Promise<AMLMonitoringRecord[]> {
    const result = await query<any>(
      `SELECT * FROM bsp_aml_monitoring
       WHERE flagged_for_review = true
       AND reviewed = false
       ORDER BY transaction_date DESC
       LIMIT $1`,
      [limit]
    );

    return result.rows.map(this.mapAMLRecord);
  }

  /**
   * Review AML record
   */
  async reviewAMLRecord(
    transactionId: string,
    reviewedBy: string,
    reviewNotes: string,
    reportToBsp = false
  ): Promise<void> {
    await query(
      `UPDATE bsp_aml_monitoring
       SET reviewed = true,
           reviewed_by = $2,
           reviewed_at = NOW(),
           review_notes = $3,
           reported_to_bsp = $4,
           reported_at = CASE WHEN $4 = true THEN NOW() ELSE reported_at END
       WHERE transaction_id = $1`,
      [transactionId, reviewedBy, reviewNotes, reportToBsp]
    );
  }

  /**
   * Get AML statistics for date range
   */
  async getStatistics(startDate: Date, endDate: Date): Promise<any> {
    const result = await query<any>(
      `SELECT
        COUNT(*) as total_monitored,
        COUNT(*) FILTER (WHERE exceeds_single_threshold) as single_threshold_breaches,
        COUNT(*) FILTER (WHERE exceeds_daily_threshold) as daily_threshold_breaches,
        COUNT(*) FILTER (WHERE exceeds_monthly_threshold) as monthly_threshold_breaches,
        COUNT(*) FILTER (WHERE flagged_for_review) as flagged_count,
        COUNT(*) FILTER (WHERE reviewed) as reviewed_count,
        SUM(amount) as total_amount,
        AVG(amount) as average_amount,
        MAX(amount) as max_amount,
        COUNT(DISTINCT user_id) as unique_users
       FROM bsp_aml_monitoring
       WHERE transaction_date BETWEEN $1 AND $2`,
      [startDate, endDate]
    );

    return result.rows[0];
  }

  /**
   * Map database row to AML monitoring record
   */
  private mapAMLRecord(row: any): AMLMonitoringRecord {
    return {
      id: row.id,
      transactionId: row.transaction_id,
      paymentId: row.payment_id,
      amount: parseFloat(row.amount),
      currency: row.currency,
      transactionType: row.transaction_type,
      userId: row.user_id,
      userType: row.user_type,
      userName: row.user_name,
      userPhone: row.user_phone,
      userEmail: row.user_email,
      exceedsSingleThreshold: row.exceeds_single_threshold,
      exceedsDailyThreshold: row.exceeds_daily_threshold,
      exceedsMonthlyThreshold: row.exceeds_monthly_threshold,
      dailyCumulativeAmount: parseFloat(row.daily_cumulative_amount),
      monthlyCumulativeAmount: parseFloat(row.monthly_cumulative_amount),
      riskLevel: row.risk_level,
      riskScore: row.risk_score,
      riskFactors: JSON.parse(row.risk_factors || '[]'),
      flaggedForReview: row.flagged_for_review,
      reviewed: row.reviewed,
      reviewedBy: row.reviewed_by,
      reviewedAt: row.reviewed_at ? new Date(row.reviewed_at) : undefined,
      reviewNotes: row.review_notes,
      reportedToBsp: row.reported_to_bsp,
      bspReportId: row.bsp_report_id,
      reportedAt: row.reported_at ? new Date(row.reported_at) : undefined,
      transactionDate: new Date(row.transaction_date),
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at),
    };
  }

  /**
   * Map database row to compliance alert
   */
  private mapAlert(row: any): ComplianceAlert {
    return {
      id: row.id,
      alertType: row.alert_type,
      severity: row.severity,
      title: row.title,
      description: row.description,
      transactionId: row.transaction_id,
      userId: row.user_id,
      reportId: row.report_id,
      alertData: JSON.parse(row.alert_data || '{}'),
      status: row.status,
      acknowledgedBy: row.acknowledged_by,
      acknowledgedAt: row.acknowledged_at ? new Date(row.acknowledged_at) : undefined,
      resolvedBy: row.resolved_by,
      resolvedAt: row.resolved_at ? new Date(row.resolved_at) : undefined,
      resolutionNotes: row.resolution_notes,
      notificationSent: row.notification_sent,
      notificationChannels: JSON.parse(row.notification_channels || '[]'),
      triggeredAt: new Date(row.triggered_at),
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at),
    };
  }

  /**
   * Map database row to suspicious activity
   */
  private mapSuspiciousActivity(row: any): SuspiciousActivity {
    return {
      id: row.id,
      activityType: row.activity_type,
      userId: row.user_id,
      userType: row.user_type,
      userName: row.user_name,
      relatedTransactions: JSON.parse(row.related_transactions || '[]'),
      detectionMethod: row.detection_method,
      patternDescription: row.pattern_description,
      severity: row.severity,
      evidence: JSON.parse(row.evidence || '{}'),
      status: row.status,
      assignedTo: row.assigned_to,
      investigationNotes: row.investigation_notes,
      falsePositive: row.false_positive,
      reportedToBsp: row.reported_to_bsp,
      bspSarId: row.bsp_sar_id,
      reportedAt: row.reported_at ? new Date(row.reported_at) : undefined,
      detectedAt: new Date(row.detected_at),
      resolvedAt: row.resolved_at ? new Date(row.resolved_at) : undefined,
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at),
    };
  }
}

/**
 * Default AML monitoring service instance
 */
let defaultService: AMLMonitoringService | null = null;

/**
 * Get default AML monitoring service
 */
export function getAMLMonitoringService(): AMLMonitoringService {
  if (!defaultService) {
    defaultService = new AMLMonitoringService();
  }
  return defaultService;
}

export default AMLMonitoringService;
